run
c
p precedence
p parser.current
n
p parser.current
n
p parser.current
step
n
p precedence
step
n
step
p parser.current
n
info breakpoints
clear 1
clear compiler.c:343
break namedVariable
run
p name
n
c
p name
n
p arg
n
clear namedVariable
break resolveLocal
c
run
n
c
p name
p *name
c
p *name
p compiler->locals
p
n
p local
l *local
p i
p compiler->locals[2]
n
p compiler->locals[1]
break push
run
p value
p value.as.obj->type
p value.as.obj->chars
p ((ObjString *)value.as.obj)->chars
break pop
run
p value
n
p vm.stack
p vm.stackTop
n
p nameString
p nameString->chars
n
p
n
p value
p value.obj->type
p value.as.obj->type
p ((ObjString *)value.as.obj)->chars
n
p vm.stack
p *vm.stack
 p vm.stack[1]
p vm.stack[2]
n
p vm.stackTop
p vm.stack
p (Value *)vm.stack
n
p vm.stack[0]
p vm.stack[1]
p vm.stackTop
p vm.stackTop - vm.stack
n
c
p value
p value.obj->type
p value.as.obj->type
p ((ObjString *)value.as.obj->type)->chars
p ((ObjString *)value.as.obj)->chars
n
p vm.stackTop
p vm.stackTop - vm.stack
printValue
p printValue(*vm.stack)
n
p string
p string->chars
p
n
p value
clear 1 2
clear 1
clear push pop
clear push
clear pop
break run
run
n
p vm.stack
p ((ObjString *)vm.stack[0].as.obj)->chars
b)
break interpret
run
p vm.stack
p (vm.stack[0].as.obj.type)
p ((ObjString *)vm.stack[0].as.obj)->chars
n
p vm.stack
c
clear interpret
break vm.c:422
run
p vm.stack
break vm.c:416
run
p vm.stack
clear vm.c:417
clear vm.c:423
break interpret
run
p vm.stack
n
p vm.stack
p vm.stackTop - vm.stack
break compile
clear interpret
fun
run
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
break declaration
clear compile
run
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
break varDeclaration
n
p vm.stackTop - vm.stack
break statement
clear statement
break statement
run
n
break varDeclaration
clear varDeclaration
break varDeclaration
clear declaration
run
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
break expression
break parseVariable
n
p vm.stackTop - vm.stack
n
c
n
p vm.stackTop - vm.stack
step
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
n
p vm.stackTop - vm.stack
info breakpoints
clear parseVariable
clear statement
clear varDeclaration
run
step
info watch
help watch
watch (vm.stackTop - vm.stack)
run
c
l
info breakpoints
run
n
c
step
n
break prefixRule
n
c
step
p parser.previous.type->prefix
p parser.previous.type
p parser.current.type
p parser.current.start
break interpret
run
watch (vm.stackTop - vm.stack
watch (vm.stackTop - vm.stack)
info watchpoints
n
help watch
help delete
delete
break push
break pop
n
c
p value
backtrace
n
c
break addConstant
c
break freeObject
clear 1
clear freeObject
break parseExpression
run
n
j
n
step
n
p parser
p *parser.previous
p *parser.current
n
run
break lambda_
n
step
n
step
n
run
c
step
n
break newSymbol
run
c
n
break printObject
run
n
p value
p AS_CSTRING(value)
n
c
p value
c
p OBJ_TYPE(value)
n
c
n
c
n
c
n
c
break printStack
clear printObject
c
n
c
n
step
n
step
n
break object.c:174
run
n
p test
p text
p text->chars
break lambda_
run
n
clear printObject
 n
n
run
n
run
step
n
break lambda_
run
n
break lambda_
run
break parseExpression
break lambda_
run
n
step
n
step
n
step
n
p parser.current->type
p parser.current->start
break lamdba_
break lambda_
run
n
printStack()
p printStack()
n
break lambda_
run
n
p parser.current->type
break lambda_
run
c
p printValue(parser.ast)
break lambda_
run
n
break parseExpression
run
n
step
n
step
n
break procedureCall
break parseList
run
n
p printObject(OBJ_VAL(list))
p *list
help
help running
n
step
p parser.current->type
p parser.current->start
p parser.previous->start
p parser.previous->length
p parser.tokenArray
p parser.tokens
p parser.tokens.array
p parser.tokens.array[0]
p parser.tokens.array[1]
p parser.tokens.array[2]
p parser.tokens.array[3]
p parser.tokens.array[4]
p parser.tokens.array[5]
break parseExpression
run
n
p parser.current->type
n
run
n
step
n
p parser.current->type
p parser.previous->type
n
step
n
step
n
p parser.current->type
break printValue
run
c
p IS_BOOL(value)
break printValue
file lisp_compiler_gdb
file ./lisp_compiler_gdb
!ls
file lisp_compiler
break printValue
 run
p IS_BOOL(value)
c
n
step
n
c
n
step
n
c
n
step
n
c
n
step
n
c
n
step
n
c
n
step
n
c
break printObject
clear printValue
n
c
n
c
n
c
n
c
n
c
n
c
n
c
n
c
n
c
n
c
n
c
break printPair
run
n
p pair->cdr
p AS_PAIR(pair->cdr)
p OBJ_TYPE(pair->cdr)
n
c
n
c
break printPair
run
n
c
n
c
n
c
n
step
n
c
break printPair
run
c
n
step
n
c
n
c
n
step
n
c
clear printPair
c
break parseList
break lambda
break lambda_
run
n
nn
n
p printValue(body)
p body
p AS_PAIR(body)
p CAR(body)
p OBJ_TYPE(CAR(body))
p CAAR(body)
p OBJ_TYPE(CAAR(body))
exit
y
yyy
yyyyyyyyy
y
yes
y
n
[n]
[y]
y
  C-c C-c
Quitq
q
y
q
n
l
file lisp_compiler.out
l
break main
n
l
r
l
(+ 1 2)
q
break conditional
run
p
n
p ifExpression
p valueToString(ifExpression)
n
 n
p valueToString(predicate)
n
p valueToString(ifExpression)
n
p parser.current
p parser.current->start
p
n
p valueToString(consequent)
q
break conditional
q
