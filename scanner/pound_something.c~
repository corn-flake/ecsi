#include "pound_something.h"

#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include "character_type_tests.h"
#include "hexadecimal.h"
#include "scan_booleans.h"
#include "scanner.h"

static char *characterNameString(char start) {
  switch (start) {
    case 't':
      return "tab";
    case 'n':
      return "null";
    case 'a':
      return "alarm";
    case 's':
      return "space";
    case 'd':
      return "delete";
    case 'e':
      return "escape";
    case 'r':
      return "return";
      /*
        'w' starts "newline" because it's the first letter in 'newline'
        that doesn't start any other character names.
       */
    case 'w':
      return "newline";
    case 'b':
      return "backspace";
    default:
      // Unreached.
      return "";
  }
}

static Token possibleCharacterName(char start) {
  if (start == 'n' && peek() == 'e') {
    /*
      We pass in 'w' because it's the first letter in 'newline'
      that doesn't start any other character names.
     */
    if (!matchString(characterNameString('w'))) {
      return errorToken("Expect 'wline' after #\ne.");
    }
    return makeToken(TOKEN_CHARACTER);
  }

  if (matchString(characterNameString(start))) {
    return makeToken(TOKEN_CHARACTER);
  }

  if (!matchString(characterNameString(start))) {
    char *restOfExpectedName = characterNameString(start) + 1;

    size_t msgLength = strlen("Expect '") + strlen(restOfExpectedName) +
                       strlen("' after #\\") + 1 /* start */ + 1 /* null */;

    char errorMsg[msgLength];
    snprintf(errorMsg, msgLength, "Expect '%s' after #\\%c", restOfExpectedName,
             start);

    return errorToken(errorMsg);
  }

  return makeToken(TOKEN_CHARACTER);
}

static char getCharacterNameStartLetter() {
  const char lettersThatStartCharacterNames[] = "abdenrst";
  char *startLetter = strchr(lettersThatStartCharacterNames, advance());
  if (startLetter == NULL) return '\0';
  return *startLetter;
}

static Token character() {
  if (peek() == 'x' && isHexDigit(peekNext())) {
    // We advance to read the 'x'.
    advance();
    hexScalarValue();
    return makeToken(TOKEN_CHARACTER);
  }

  char startLetter = getCharacterNameStartLetter();

  if (startLetter == '\0') {
    return makeToken(TOKEN_CHARACTER);
  } else {
    return possibleCharacterName(startLetter);
  }
}

Token poundSomething() {
  char c = advance();
  switch (c) {
    case 't':
      return scanTrue();
    case 'f':
      return scanFalse();
    case '(':
      return makeToken(TOKEN_POUND_LEFT_PAREN);
    case '\\':
      return character();
    case 'u':
      if (peek() != '8' || peekNext() != '(')
        return errorToken("Expected '8(' after '#u'");
      return makeToken(TOKEN_POUND_U8_LEFT_PAREN);
  }
  return errorToken("Expected 't', 'f', 'u' or '(' after '#'");
}
