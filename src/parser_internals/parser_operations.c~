#include "parser_operations.h"

#include <stdio.h>

#include "../object.h"
#include "../parser.h"
#include "../value.h"
#include "../vm.h"

void errorAt(Token *token, const char *message) {
  if (parser.panicMode) return;
  parser.panicMode = true;
  fprintf(stderr, "[line %zu] Error", token->line);
  if (token->type == TOKEN_EOF) {
    fprintf(stderr, " at end");
  } else if (token->type == TOKEN_ERROR) {
    /*
      We don't do anything if the token is an error because if it is,
      the token's error message will be passed as the MESSAGE
     */
  } else {
    fprintf(stderr, " at '%.*s'", (int)token->length, token->start);
  }
  fprintf(stderr, ": %s\n", message);
  parser.hadError = true;
}

void error(const char *message) { errorAt(parser.previous, message); }

void errorAtCurrent(const char *message) { errorAt(parser.current, message); }

/*
  We call this function parserAdvance to avoid name conflict
  with the scanner's advance function.
 */
void parserAdvance() {
  parser.previous = parser.current;

  while (true) {
    parser.current++;
    if (parser.current->type != TOKEN_ERROR) break;
    errorAt(parser.current, parser.current->start);
  }
}

void consume(TokenType type, const char *message) {
  if (parser.current->type == type) {
    parserAdvance();
    return;
  }
  errorAtCurrent(message);
}

bool check(TokenType type) { return parser.current->type == type; }

bool parserMatch(TokenType type) {
  if (!check(type)) return false;
  parserAdvance();
  return true;
}

Value parseList(bool parseDatums) {
  if (check(TOKEN_RIGHT_PAREN)) return NIL_VAL;

  Value firstElement = parseDatums ? parseDatum() : parseExpression();

  push(firstElement);
  ObjPair *list = newPair(firstElement, NIL_VAL);
  pop();  // firstElement

  push(OBJ_VAL(list));
  while (!check(TOKEN_RIGHT_PAREN)) {
    append(list, parseDatums ? parseDatum() : parseExpression());
  }
  pop();  // list

  return OBJ_VAL(list);
}
